:: This wraps functionality of `Env` so that we can capture output
:: generated when running a spec allowing us to better test `Spec` itself.
:class val Spec.Env
  :let _env (Env | None)
  :let _capture (Spec.Env.Capture | None)

  :new val (@_env, @_capture = None)
  :new val capture(capturer Spec.Env.Capture.Notify):
    @_env = None
    @_capture = Spec.Env.Capture.new(capturer)

  :fun val _with_capture
    cap = @_capture
    if (cap <: Spec.Env.Capture) (yield cap)

  :fun val _with_env
    env = @_env
    if (env <: Env) (yield env)

  :: Mark the entire process as a failure.
  :fun val fail None
    @_with_env -> (env | env.exit_code = 1)
    @_with_capture -> (cap | cap.exit_code = 1)

  :: Print a bug message and mark the entire process as a failure.
  :fun val bug(text String) None
    @write_err("You've encountered a bug in the spec package: \(text)\n")
    @fail

  :: Write a string to stderr.
  :fun val write_err(data String)
    @_with_env -> (env | env.err.write(data))
    @_with_capture -> (cap | cap.write_err(data))

  :: Print a string to stderr.
  :fun val print_err(data String): @write_err("\(data)\n")

  :: Write a string to stdout.
  :fun val write_out(data String)
    @_with_env -> (env | env.out.write(data))
    @_with_capture -> (cap | cap.write_out(data))

  :: Print a string to stdout.
  :fun val print_out(data String): @write_out("\(data)\n")

  :: Notify the `Spec.Env` that all output has been generated.
  :fun val done
    @_with_capture -> (cap | cap.report)


:actor val Spec.Env.Capture
  :let err Array(String): []
  :let out Array(String): []
  :var exitcode I32: 0
  :let notify Spec.Env.Capture.Notify

  :new (@notify)

  :be write_err(data String): @err << data
  :be write_out(data String): @out << data
  :be "exit_code="(value): @exitcode = value

  :be report
    @notify.capture_report(
      String.join(@err, "")
      String.join(@out, "")
      @exitcode
    )

:trait tag Spec.Env.Capture.Notify
  :be capture_report(err String, out String, exitcode I32)

